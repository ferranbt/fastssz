package ssz

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestBitlist(t *testing.T) {
	res := []string{}
	err := filepath.Walk("./spectests/fixtures/bitlist", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			res = append(res, path)
		}
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}

	for _, i := range res {
		t.Run(i, func(t *testing.T) {
			serialized, err := ioutil.ReadFile(i)
			if err != nil {
				t.Fatal(err)
			}

			var maxSize uint64

			testName := strings.Split(i, "/")[3]
			if strings.Contains(testName, "_no_") {
				maxSize = 1000
			} else {
				// decode maxSize from name
				num, err := strconv.Atoi(strings.Split(testName, "_")[1])
				if err != nil {
					t.Fatal(err)
				}
				maxSize = uint64(num)
			}

			if err := ValidateBitlist(serialized, maxSize); err == nil {
				t.Fatal("bad")
			}
		})
	}
}

func TestBitlist_MaxValue(t *testing.T) {
	tests := []struct {
		name    string
		bitlist []byte
		maxSize uint64
		valid   bool
	}{
		{
			name: "At the maximum limit",
			bitlist: []byte{ /* 2048 bits */ 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				/* delimiter bit*/ 0b00000001},
			maxSize: 2048,
			valid:   true,
		},
		{
			name: "Just below maximum limit",
			bitlist: []byte{ /* 2040 bits */ 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				/* last byte( with delimiting bit) */ 0b00011111},
			maxSize: 2048,
			valid:   true,
		},
		{
			name: "Above the maximum limit",
			bitlist: []byte{ /* 2048 bits */ 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				/* delimiter bit*/ 0b00000010},
			maxSize: 2048,
			valid:   false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ValidateBitlist(tt.bitlist, tt.maxSize)
			if tt.valid && err != nil {
				t.Error(err)
			}
			if !tt.valid && err == nil {
				t.Error("Invalid bitlist did not fail validation")
			}
		})
	}
}

func TestEncode_ExtendUint(t *testing.T) {
	if v0 := Extend([]uint64{}, 0); v0 == nil {
		t.Fatal("uint64 cannot be nil")
	}
	if v1 := Extend([]uint16{}, 0); v1 == nil {
		t.Fatal("uint16 cannot be nil")
	}
	if v2 := Extend([]uint8{}, 0); v2 == nil {
		t.Fatal("uint8 cannot be nil")
	}
}

func TestUnmarshalDynamic(t *testing.T) {
	{
		buf := []byte{}
		buf = WriteOffset(buf, 4*1)
		buf = append(buf, 0x1)

		num, err := DecodeDynamicLength(buf, 10)
		require.NoError(t, err)

		err = UnmarshalDynamic(buf, num, func(i int, b []byte) error {
			if !bytes.Equal(b, []byte{0x1}) {
				return fmt.Errorf("bad")
			}
			return nil
		})
		require.NoError(t, err)
	}

	{
		buf := []byte{}
		buf = WriteOffset(buf, 0)
		buf = append(buf, 0x1)

		num, err := DecodeDynamicLength(buf, 10)
		require.NoError(t, err)

		err = UnmarshalDynamic(buf, num, func(i int, b []byte) error {
			return nil
		})
		require.Equal(t, ErrSize, err)
	}
}

func TestReadOffset_ValidFirstOffset(t *testing.T) {
	om := NewOffsetMarker(1000, 100)
	buf := WriteOffset(nil, 100)

	result, err := om.ReadOffset(buf)

	require.NoError(t, err)
	require.Equal(t, uint64(100), result)
	require.Equal(t, uint64(100), *om.LastOffset)
}

func TestReadOffset_FirstOffsetDoesNotMatchFixedSize(t *testing.T) {
	om := NewOffsetMarker(1000, 100)
	buf := WriteOffset(nil, 150)

	_, err := om.ReadOffset(buf)
	require.Error(t, err)
	require.Equal(t, ErrInvalidVariableOffset, err)
}

func TestReadOffset_OffsetExceedsTotalSize(t *testing.T) {
	om := NewOffsetMarker(1000, 100)
	buf := WriteOffset(nil, 1500)

	_, err := om.ReadOffset(buf)

	require.Error(t, err)
	require.Equal(t, err, ErrOffset)
}

func TestReadOffset_SequentialOffsets(t *testing.T) {
	om := NewOffsetMarker(1000, 100)

	// First offset
	buf1 := WriteOffset(nil, 100)
	result1, err := om.ReadOffset(buf1)
	require.NoError(t, err)
	require.Equal(t, uint64(100), result1)

	// Second offset (increasing - valid)
	buf2 := WriteOffset(nil, 200)
	result2, err := om.ReadOffset(buf2)
	require.NoError(t, err)
	require.Equal(t, uint64(200), result2)
	require.Equal(t, uint64(200), *om.LastOffset)

	// Fourth offset (increasing again - valid)
	buf3 := WriteOffset(nil, 300)
	result3, err := om.ReadOffset(buf3)
	require.NoError(t, err)
	require.Equal(t, uint64(300), result3)

	// Fifth offset (decreasing - invalid)
	buf4 := WriteOffset(nil, 250)
	_, err = om.ReadOffset(buf4)
	require.Error(t, err)
	require.Equal(t, err, ErrOffsetNotIncreasing)
}

func TestReadOffset_SecondOffsetExceedsTotalSize(t *testing.T) {
	om := NewOffsetMarker(1000, 100)

	// First valid offset
	buf1 := WriteOffset(nil, 100)
	_, err := om.ReadOffset(buf1)
	require.NoError(t, err)

	// Second offset exceeds total size
	buf2 := WriteOffset(nil, 1500)
	_, err = om.ReadOffset(buf2)

	require.Error(t, err)
	require.Equal(t, err, ErrOffset)
}

func TestReadOffset_MultipleValidOffsets(t *testing.T) {
	om := NewOffsetMarker(1000, 100)

	offsets := []int{100, 200, 300, 400, 500}
	for _, offset := range offsets {
		buf := WriteOffset(nil, offset)
		result, err := om.ReadOffset(buf)

		require.NoError(t, err)
		require.Equal(t, uint64(offset), result)
	}

	require.Equal(t, uint64(500), *om.LastOffset)
}

// Benchmark data - 8 bytes for uint64
var testData = []byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}

func BenchmarkUint64DirectConversion(b *testing.B) {
	b.ReportAllocs()

	for i := 0; i < b.N; i++ {
		_ = binary.LittleEndian.Uint64(testData)
	}
}

func BenchmarkUint64GenericConversion(b *testing.B) {
	b.ReportAllocs()

	for i := 0; i < b.N; i++ {
		_ = UnmarshallValue[uint64](testData)
	}
}

func marshalUint64(dst []byte, i uint64) []byte {
	buf := make([]byte, 8)
	binary.LittleEndian.PutUint64(buf, i)
	dst = append(dst, buf...)
	return dst
}

func BenchmarkUint64MarshalDirect(b *testing.B) {
	b.ReportAllocs()

	buf := make([]byte, 8)
	for i := 0; i < b.N; i++ {
		marshalUint64(buf[:0], 0x0102030405060708)
	}
}

func BenchmarkUint64MarshalGeneric(b *testing.B) {
	b.ReportAllocs()

	buf := make([]byte, 8)
	for i := 0; i < b.N; i++ {
		_ = MarshalValue[uint64](buf[:0], 0x0102030405060708)
	}
}
