// Code generated by fastssz. DO NOT EDIT.
// Hash: b89ee134b519595b8276174178242203f6bfb9e0594654a23e1c35e5fb8b5369
// Version: 0.1.4
package testcases

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the Case5A object
func (c *Case5A) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the Case5A object to a target array
func (c *Case5A) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'A'
	if size := len(c.A); size != 2 {
		err = ssz.ErrVectorLengthFn("Case5A.A", size, 2)
		return
	}
	for ii := 0; ii < 2; ii++ {
		if size := len(c.A[ii]); size != 2 {
			err = ssz.ErrBytesLengthFn("Case5A.A[ii]", size, 2)
			return
		}
		dst = append(dst, c.A[ii]...)
	}

	// Field (1) 'B'
	if size := len(c.B); size != 2 {
		err = ssz.ErrVectorLengthFn("Case5A.B", size, 2)
		return
	}
	for ii := 0; ii < 2; ii++ {
		if size := len(c.B[ii]); size != 2 {
			err = ssz.ErrBytesLengthFn("Case5A.B[ii]", size, 2)
			return
		}
		dst = append(dst, c.B[ii]...)
	}

	// Field (2) 'C'
	if size := len(c.C); size != 2 {
		err = ssz.ErrVectorLengthFn("Case5A.C", size, 2)
		return
	}
	for ii := 0; ii < 2; ii++ {
		if size := len(c.C[ii]); size != 2 {
			err = ssz.ErrBytesLengthFn("Case5A.C[ii]", size, 2)
			return
		}
		dst = append(dst, c.C[ii]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Case5A object
func (c *Case5A) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(c, buf)
}

// UnmarshalSSZTail unmarshals the Case5A object and returns the remaining bufferÂº
func (c *Case5A) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := c.SizeSSZ(false)
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'A'
	c.A = make([][]byte, 2)
	for ii := 0; ii < 2; ii++ {
		c.A[ii], buf = ssz.UnmarshalBytes(c.A[ii], buf, 2)
	}

	// Field (1) 'B'
	c.B = make([]Case5Bytes, 2)
	for ii := 0; ii < 2; ii++ {
		c.B[ii], buf = ssz.UnmarshalBytes(c.B[ii], buf, 2)
	}

	// Field (2) 'C'
	c.C = make([][]byte, 2)
	for ii := 0; ii < 2; ii++ {
		c.C[ii], buf = ssz.UnmarshalBytes(c.C[ii], buf, 2)
	}

	return buf, nil
}

// SizeSSZ returns the ssz encoded size in bytes for the Case5A object
func (c *Case5A) SizeSSZ(includeDynamic bool) (size int) {
	size = ((2 * 2) + (2 * 2) + (2 * 2))
	return
}

// HashTreeRoot ssz hashes the Case5A object
func (c *Case5A) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the Case5A object with a hasher
func (c *Case5A) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'A'
	{
		if size := len(c.A); size != 2 {
			err = ssz.ErrVectorLengthFn("Case5A.A", size, 2)
			return
		}
		subIndx := hh.Index()
		for _, i := range c.A {
			if len(i) != 2 {
				err = ssz.ErrBytesLength
				return
			}
			hh.PutBytes(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (1) 'B'
	{
		if size := len(c.B); size != 2 {
			err = ssz.ErrVectorLengthFn("Case5A.B", size, 2)
			return
		}
		subIndx := hh.Index()
		for _, i := range c.B {
			if len(i) != 2 {
				err = ssz.ErrBytesLength
				return
			}
			hh.PutBytes(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (2) 'C'
	{
		if size := len(c.C); size != 2 {
			err = ssz.ErrVectorLengthFn("Case5A.C", size, 2)
			return
		}
		subIndx := hh.Index()
		for _, i := range c.C {
			if len(i) != 2 {
				err = ssz.ErrBytesLength
				return
			}
			hh.PutBytes(i)
		}
		hh.Merkleize(subIndx)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Case5A object
func (c *Case5A) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}
